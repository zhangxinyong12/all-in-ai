# 提示词工程详解

> 大模型应用的"灵魂技能"
> 掌握提示词工程 = 掌握与大模型沟通的艺术

---

## 一、什么是提示词工程？

### 1.1 基本定义

**提示词（Prompt）**：你给大模型的所有输入文本

**提示词工程**：设计和优化提示词，让大模型输出更高质量结果的方法

### 1.2 核心思想

大模型本质是**预测下一个词**，提示词工程就是**引导模型按你想要的方式预测**

```
输入：你今天吃什么？
输出：我建议吃...（随机性高）

输入：你是一位营养师，请根据健康原则，推荐今天的午餐，要求：低脂、高蛋白、800卡路里以内，输出格式：菜名 + 主要食材 + 营养价值
输出：烤鸡胸肉沙拉 + 鸡胸肉、生菜、番茄 + 蛋白质35g、脂肪8g、热量450kcal（精准可控）
```

---

## 二、提示词的基本结构

### 2.1 六要素框架

```
【角色设定】 + 【任务描述】 + 【输入数据】 + 【输出格式】 + 【约束条件】 + 【示例】
```

### 2.2 逐个解析

**1. 角色设定**
```
你是一位资深的前端开发专家
你是一位经验丰富的产品经理
你是一位专业的技术写作专家
```

**作用：** 激活模型在特定领域的知识

---

**2. 任务描述**
```
请审查以下React代码，指出潜在问题
请将以下技术文档改写为通俗易懂的博客
请分析用户需求并生成产品需求文档
```

**作用：** 明确告诉模型要做什么

---

**3. 输入数据**
```
代码：
{code}

文档：
{document}

用户需求：
{requirements}
```

**作用：** 提供需要处理的具体内容

---

**4. 输出格式**
```
请以JSON格式输出，包含以下字段：
- issues: 问题列表
- severity: 严重程度
- suggestions: 改进建议

输出示例：
{
  "issues": [...],
  "severity": "high",
  "suggestions": [...]
}
```

**作用：** 控制输出结构，方便后续处理

---

**5. 约束条件**
```
要求：
- 输出长度不超过500字
- 使用Markdown格式
- 只列出关键问题，不写废话
- 避免使用专业术语
```

**作用：** 限制输出范围，提高质量

---

**6. 示例**
```
输入：
const [count, setCount] = useState(0)

输出：
{
  "issues": [],
  "severity": "none",
  "suggestions": "代码良好，建议添加useEffect来监听count变化"
}

输入：
const [count, setCount] = useState()
setCount(count + 1)

输出：
{
  "issues": ["useState缺少初始值"],
  "severity": "high",
  "suggestions": "useState(0)应该提供初始值"
}
```

**作用：** 通过示例引导模型理解期望

---

## 三、核心技巧详解

### 3.1 Zero-Shot（零样本提示）

不提供示例，直接给出任务

```
你是一位代码审查专家，请审查以下React代码，找出所有潜在问题：

{code}

输出要求：
1. 以列表形式输出
2. 每个问题包含：问题描述 + 严重程度 + 修复建议
```

**优点：** 简单直接，无需准备示例  
**缺点：** 对复杂任务效果不稳定

**适用场景：** 简单明确的任务

---

### 3.2 Few-Shot（少样本提示）

提供1-3个示例，引导模型理解模式

```
你是一位前端代码风格检查员，根据以下示例判断代码风格：

示例1：
输入：
const myName = "Tom"
输出：✓ 风格良好（驼峰命名，语义清晰）

示例2：
输入：
const n = "Tom"
输出：✗ 风格不佳（变量名过短，无语义）

示例3：
输入：
const user_name = "Tom"
输出：✗ 风格不佳（应该用驼峰命名）

现在请判断以下代码：
输入：
const getUserData = () => {...}
输出：
```

**优点：** 提升复杂任务的准确性  
**缺点：** 需要准备高质量示例

**适用场景：** 需要特定格式或风格的输出

---

### 3.3 Chain-of-Thought（思维链）

让模型逐步思考，分解复杂问题

```
你是一位前端性能优化专家，请分析以下网页的性能瓶颈并给出优化方案：

{page_code}

请按以下步骤思考：
步骤1：分析页面结构和渲染流程
步骤2：识别可能的性能问题点
步骤3：评估每个问题的影响程度
步骤4：提出针对性的优化方案

开始你的分析...
```

**变体1：显式思维链**
```
请逐步思考：
1. 这个组件做了什么？
2. 为什么会导致性能问题？
3. 如何优化？
4. 预期性能提升多少？
```

**变体2：自动思维链**
```
请用"思考：..."的格式逐步分析问题
思考：...（第一步）
思考：...（第二步）
最终答案：...
```

**优点：** 大幅提升复杂任务的准确性  
**缺点：** 增加token消耗

**适用场景：** 逻辑推理、代码分析、复杂决策

---

### 3.4 Self-Consistency（自我一致性）

让模型多次回答，选择最一致的结果

```
任务：判断这段代码是否有内存泄漏风险

请独立分析3次，每次使用不同的思考角度：

分析1：
...

分析2：
...

分析3：
...

综合判断：根据3次分析，最终结论是...
```

**优点：** 提高答案的稳定性  
**缺点：** 成本较高

**适用场景：** 关键决策、风险评估

---

## 四、进阶技巧

### 4.1 角色扮演强化

不仅设定角色，还要给出角色背景

```
你是一位有10年经验的前端架构师，曾在阿里、腾讯负责大型前端项目，精通React性能优化和工程化建设。你擅长用简单易懂的语言解释复杂技术概念，你的目标是帮助初级开发者快速成长。

任务：解释React虚拟DOM的原理和优势

要求：
1. 用类比方式解释（如：可以对比真实DOM和虚拟DOM）
2. 避免使用过多技术术语
3. 突出虚拟DOM的核心优势
4. 字数控制在500字以内
```

**效果：** 角色越具体，输出越贴合需求

---

### 4.2 负面约束

明确告诉模型**不要**做什么

```
你是一位代码注释生成专家，请为以下代码生成注释：

{code}

要求：
✓ 注释要简洁明了
✓ 说明代码的目的和关键逻辑
✗ 不要重复代码本身的描述
✗ 不要使用过于宽泛的词（如"处理数据"、"函数"）
✗ 不要添加无用废话

示例：
错误注释：
// 定义一个函数
function getUser() {...}

正确注释：
// 从本地存储获取用户信息，如果不存在则返回null
function getUser() {...}
```

**效果：** 显著减少废话和低质量输出

---

### 4.3 结构化输出

强制使用特定格式输出

```
请分析以下React组件的性能问题：

{component_code}

请严格按以下JSON格式输出：

```json
{
  "component_name": "组件名称",
  "issues": [
    {
      "type": "问题类型（如：过度渲染、内存泄漏）",
      "description": "问题描述",
      "severity": "high|medium|low",
      "location": "问题代码位置（行号）",
      "fix_suggestion": "修复建议"
    }
  ],
  "overall_score": "性能评分（0-100）",
  "summary": "简要总结"
}
```
```

**效果：** 输出可直接用于程序处理

---

### 4.4 上下文管理

长对话中管理上下文

```
当前对话历史：
{conversation_history}

用户最新问题：
{new_question}

请基于对话历史和最新问题，回答用户。如果历史信息不足，请主动询问缺失信息。
```

**技巧：**
- 提取关键信息传递
- 使用"记忆总结"压缩历史
- 明确告知模型历史信息的作用

---

### 4.5 迭代优化

分步优化提示词

```
第一轮：基础提示词
你帮我审查代码

第二轮：添加角色
你是一位代码审查专家，帮我审查代码

第三轮：添加输出格式
...请以JSON格式输出，包含问题、严重程度、建议

第四轮：添加约束
...避免废话，只列出关键问题

第五轮：添加示例
...参考以下示例...
```

**效果：** 每次迭代提升质量

---

## 五、实战案例

### 案例1：智能代码审查

**需求：** 审查React代码，指出问题和改进建议

**提示词设计：**

```markdown
你是一位资深的React代码审查专家，在Meta和Google有5年React开发经验。你精通React最佳实践、性能优化和代码规范。

任务：审查以下React代码，找出所有问题并提供改进建议

代码：
```tsx
{code}
```

请按以下步骤分析：

步骤1：检查React Hooks使用是否正确
步骤2：检查是否存在性能问题（过度渲染、内存泄漏等）
步骤3：检查代码可读性和可维护性
步骤4：检查是否符合React最佳实践

输出要求：
1. 使用以下JSON格式：
```json
{
  "summary": "代码整体评价（1-2句话）",
  "score": "代码评分（0-100）",
  "issues": [
    {
      "category": "问题类别（如：hooks使用/性能问题/代码规范）",
      "severity": "high|medium|low",
      "description": "详细描述问题",
      "location": "代码位置（行号）",
      "current_code": "问题代码片段",
      "suggested_code": "建议修改后的代码",
      "explanation": "为什么需要修改"
    }
  ],
  "strengths": ["代码优点1", "代码优点2"]
}
```

2. 严重程度判断标准：
   - high：影响功能正确性或导致严重性能问题
   - medium：影响可维护性或导致轻微性能问题
   - low：代码风格或可读性问题

3. 如果没有发现问题，issues数组为空

示例：
输入：
const [count, setCount] = useState()
useEffect(() => {
  setCount(count + 1)
})

输出：
```json
{
  "summary": "代码存在严重错误，useState缺少初始值且useEffect依赖配置不正确",
  "score": 40,
  "issues": [
    {
      "category": "hooks使用",
      "severity": "high",
      "description": "useState缺少初始值，可能导致undefined相关错误",
      "location": "第1行",
      "current_code": "const [count, setCount] = useState()",
      "suggested_code": "const [count, setCount] = useState(0)",
      "explanation": "useState应该提供初始值以避免undefined问题"
    },
    {
      "category": "hooks使用",
      "severity": "high",
      "description": "useEffect缺少依赖数组，会导致无限循环",
      "location": "第2-4行",
      "current_code": "useEffect(() => {\n  setCount(count + 1)\n})",
      "suggested_code": "useEffect(() => {\n  setCount(c => c + 1)\n}, [])",
      "explanation": "应该添加依赖数组或使用函数式更新"
    }
  ],
  "strengths": []
}
```

现在开始审查...
```

**关键设计点：**
- 详细的角色背景
- 分步骤分析
- 明确的输出格式（JSON）
- 严重程度判断标准
- 高质量示例

---

### 案例2：文档生成

**需求：** 根据React组件自动生成技术文档

**提示词设计：**

```markdown
你是一位专业的技术文档工程师，擅长为React组件编写清晰、详细、易于理解的文档。你的目标文档受众是初级到中级前端开发者。

任务：为以下React组件生成完整的技术文档

组件代码：
```tsx
{component_code}
```

请生成以下文档结构：

## 组件概述
简要说明组件的用途和主要功能（2-3句话）

## Props 接口
列出所有Props，格式如下：
| Prop | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| name | string | 是 | - | 组件名称 |
| ... | ... | ... | ... | ... |

## 使用示例
提供3个不同场景的使用示例，从简单到复杂

示例1：基础用法
```tsx
// 代码
```

示例2：自定义样式
```tsx
// 代码
```

示例3：复杂场景
```tsx
// 代码
```

## 注意事项
列出使用时需要注意的事项，包括：
- 常见错误使用方式
- 性能考虑
- 兼容性问题
- 其他重要提醒

## 相关链接
- 设计稿链接
- 相关组件链接
- 问题反馈渠道

文档要求：
1. 使用Markdown格式
2. 代码示例使用TypeScript
3. 说明文字简洁清晰，避免过于技术化的术语
4. 使用表格展示Props，便于快速查阅
5. 示例代码要有注释说明

示例输出：
```markdown
# Button 组件

## 组件概述
Button组件是一个通用的按钮组件，支持多种样式和交互状态。适用于表单提交、页面导航、操作触发等场景。

## Props 接口
| Prop | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| children | ReactNode | 是 | - | 按钮内容 |
| variant | 'primary' \| 'secondary' \| 'text' | 否 | 'primary' | 按钮样式变体 |
| size | 'small' \| 'medium' \| 'large' | 否 | 'medium' | 按钮尺寸 |
| disabled | boolean | 否 | false | 是否禁用 |
| loading | boolean | 否 | false | 是否显示加载状态 |

## 使用示例
...
```

现在开始生成文档...
```

---

### 案例3：需求分析

**需求：** 将用户口语化的需求转化为结构化的产品需求文档

**提示词设计：**

```markdown
你是一位经验丰富的产品经理，擅长将用户模糊的需求转化为清晰、可执行的产品需求文档（PRD）。你有5年B端产品经验，了解前端技术实现细节。

任务：分析以下用户需求，生成完整的产品需求文档

用户需求：
{user_requirements}

请按以下结构生成PRD：

## 1. 需求概述
将用户需求整理成简洁明了的需求概述，包括：
- 背景说明
- 核心目标
- 目标用户

## 2. 功能清单
将需求拆解为具体的功能点，每个功能点包含：
- 功能名称
- 功能描述（用户故事格式：作为...我想要...以便于...）
- 优先级（P0/P1/P2）
- 复杂度评估（高/中/低）

## 3. 用户流程
用步骤描述用户使用流程：
步骤1：用户进入...
步骤2：用户点击...
步骤3：系统显示...

## 4. 页面元素
列出涉及的页面和关键元素：
- 页面名称
- 关键元素（按钮、输入框、列表等）
- 交互说明

## 5. 数据字段
列出需要的数据字段：
- 字段名称
- 数据类型
- 说明
- 是否必填

## 6. 异常处理
列出可能的异常情况和处理方式：
- 异常场景
- 提示文案
- 处理方式

## 7. 验收标准
定义清晰的验收标准：
- 功能验收
- 性能验收
- 兼容性验收

## 8. 技术建议
从产品角度给出技术实现建议：
- 前端技术选型建议
- 可能的技术难点
- 性能优化建议

输出要求：
1. 使用Markdown格式
2. 内容详实但不冗余
3. 对于模糊的需求点，标注"需要进一步确认"
4. 使用表格展示数据字段
5. 优先级标准：
   - P0：核心功能，必须实现
   - P1：重要功能，影响用户体验
   - P2：锦上添花，可延后

现在开始分析...
```

---

## 六、提示词优化流程

### 6.1 迭代优化法

```
第1轮：简单提示词
→ 输出不满意

第2轮：添加角色设定
→ 输出有改善但格式不对

第3轮：添加输出格式
→ 格式正确但内容不深入

第4轮：添加约束条件
→ 内容质量提升但仍有问题

第5轮：添加示例
→ 输出达到预期
```

### 6.2 对比测试法

同时测试多个版本的提示词：

```
版本A：基础版
你帮我审查代码

版本B：+角色
你是一位代码审查专家，帮我审查代码

版本C：+角色+格式
你是一位代码审查专家...请按JSON格式输出...

版本D：+角色+格式+示例
你是一位代码审查专家...请参考以下示例...

测试相同输入，对比输出质量
```

### 6.3 A/B测试

在生产环境中测试不同提示词的效果：

```
用户请求 → 提示词A → 输出A
用户请求 → 提示词B → 输出B

对比指标：
- 用户满意度
- 输出质量评分
- Token消耗
- 响应速度
```

---

## 七、常见问题与解决方案

### 问题1：输出不稳定

**现象：** 同样的提示词，每次输出不同

**原因：** Temperature参数过高

**解决：**
- 降低Temperature（0.1-0.3）
- 使用Self-Consistency多次验证
- 添加明确的输出约束

---

### 问题2：输出太啰嗦

**现象：** 模型输出大量无关内容

**解决：**
- 添加"简洁"、"直接"等约束
- 限制输出长度
- 添加负面约束（不要说废话）

---

### 问题3：输出格式不正确

**现象：** 要求JSON但输出了其他格式

**解决：**
- 提供详细示例
- 在输出要求中强调格式
- 后续添加格式验证和重试逻辑

---

### 问题4：模型理解错误

**现象：** 模型误解了任务意图

**解决：**
- 更清晰地描述任务
- 提供更多示例
- 分步骤描述（思维链）
- 使用角色设定强化

---

### 问题5：Token超限

**现象：** 输入内容太长，超出上下文窗口

**解决：**
- 压缩提示词，去除冗余
- 分段处理长内容
- 使用摘要总结历史信息
- 选择更大上下文的模型

---

## 八、高级技巧

### 8.1 提示词模板化

将常用的提示词抽象成模板：

```typescript
interface PromptTemplate {
  role: string;
  task: string;
  input: string;
  outputFormat: string;
  constraints?: string[];
  examples?: Example[];
}

function buildPrompt(template: PromptTemplate): string {
  return `
${template.role}

任务：${template.task}

输入：
${template.input}

输出要求：
${template.outputFormat}
${template.constraints ? `约束条件：\n${template.constraints.join('\n')}` : ''}
${template.examples ? `示例：\n${formatExamples(template.examples)}` : ''}
  `.trim();
}
```

---

### 8.2 提示词版本管理

```typescript
const promptVersions = {
  v1: "基础版本",
  v2: "添加角色设定",
  v3: "优化输出格式",
  v4: "当前最佳版本"
};

function getPrompt(version: string): string {
  return promptVersions[version];
}
```

---

### 8.3 提示词测试框架

```typescript
async function testPrompt(
  prompt: string,
  testCases: TestCase[]
): Promise<TestResult> {
  const results = [];

  for (const testCase of testCases) {
    const output = await callLLM(prompt, testCase.input);
    const score = evaluateOutput(output, testCase.expected);
    results.push({ testCase, output, score });
  }

  return {
    prompt,
    results,
    averageScore: calculateAverage(results)
  };
}
```

---

### 8.4 动态提示词生成

根据上下文动态生成提示词：

```typescript
function generateContextualPrompt(
  basePrompt: string,
  context: {
    userLevel: 'beginner' | 'intermediate' | 'expert';
    taskComplexity: 'simple' | 'medium' | 'complex';
    timeConstraint?: number;
  }
): string {
  let prompt = basePrompt;

  if (context.userLevel === 'beginner') {
    prompt += '\n\n注意：请用简单的语言解释，避免专业术语。';
  }

  if (context.taskComplexity === 'complex') {
    prompt += '\n\n请使用思维链逐步分析问题。';
  }

  if (context.timeConstraint) {
    prompt += `\n\n请尽量简洁，输出不超过${context.timeConstraint}字。`;
  }

  return prompt;
}
```

---

## 九、学习资源

### 官方资源
- OpenAI Prompt Engineering Guide
- Anthropic Prompt Library
- Learn Prompting (learnprompting.org)

### 中文资源
- 《提示工程指南》中文版
- B站：提示词工程教程
- 知乎：提示词工程专栏

### 实践平台
- PromptBase (prompt marketplace)
- FlowGPT (prompt library)
- 本地测试：各种AI聊天界面

---

## 十、学习建议

### 第一周：基础掌握
- 理解提示词工程概念
- 掌握六要素框架
- 实践Zero-Shot和Few-Shot

### 第二周：技巧应用
- 学习Chain-of-Thought
- 实践角色扮演和负面约束
- 掌握结构化输出

### 第三周：实战项目
- 设计3个不同场景的提示词
- 进行迭代优化
- 对比测试不同版本

### 第四周：进阶技巧
- 学习模板化和版本管理
- 构建测试框架
- 研究高级应用案例

---

## 十一、总结

### 核心要点

1. **结构化是关键**：六要素框架是基础
2. **示例很重要**：Few-Shot大幅提升质量
3. **思维链有用**：复杂任务必须用
4. **迭代是常态**：持续优化提示词
5. **测试验证**：A/B测试找最佳版本

### 技能等级

| 等级 | 能力 | 描述 |
|------|------|------|
| 初级 | 会用 | 能使用基础提示词得到可用结果 |
| 中级 | 会调 | 能优化提示词提升质量 |
| 高级 | 会设计 | 能设计复杂提示词解决专业问题 |
| 专家 | 会系统化 | 能构建提示词工程体系 |

---

*文档版本：v1.0*
*最后更新：2026-01-30*
